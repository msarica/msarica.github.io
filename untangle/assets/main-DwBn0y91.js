(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))i(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&i(a)}).observe(document,{childList:!0,subtree:!0});function t(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(n){if(n.ep)return;n.ep=!0;const s=t(n);fetch(n.href,s)}})();class d{static distance(e,t){const i=t.x-e.x,n=t.y-e.y;return Math.sqrt(i*i+n*n)}static pointInCircle(e,t,i){return this.distance(e,t)<=i}static lineSegmentsIntersect(e,t,i,n){const s=(n.y-i.y)*(t.x-e.x)-(n.x-i.x)*(t.y-e.y);if(Math.abs(s)<1e-10)return!1;const a=((n.x-i.x)*(e.y-i.y)-(n.y-i.y)*(e.x-i.x))/s,r=((t.x-e.x)*(e.y-i.y)-(t.y-e.y)*(e.x-i.x))/s;return a>=0&&a<=1&&r>=0&&r<=1}static randomPosition(e,t,i=50){return{x:i+Math.random()*(e-2*i),y:i+Math.random()*(t-2*i)}}static randomPositionDistributed(e,t,i=50){const n=Math.floor(Math.sqrt((e-2*i)*(t-2*i)/(i*i))),s=Math.floor((t-2*i)/i),a=(e-2*i)/n,r=(t-2*i)/s,o=Math.floor(Math.random()*n),c=Math.floor(Math.random()*s);return{x:i+o*a+Math.random()*a,y:i+c*r+Math.random()*r}}static clamp(e,t,i){return Math.min(Math.max(e,t),i)}}class v{static CIRCLE_RADIUS=30;static MIN_DISTANCE=120;static generateLevel(e,t,i){if(i&&i.levelNumber===e&&i.canvasSize.x===t.x&&i.canvasSize.y===t.y)return{circles:this.deepCopyCircles(i.circles),lines:this.deepCopyLines(i.lines),solution:i.solution?{circles:this.deepCopyCircles(i.solution.circles),lines:this.deepCopyLines(i.solution.lines)}:void 0};const{nodeCount:n,connectionsPerNode:s}=this.calculateLevelParameters(e);return this.generateSolvableLevel(n,s,t)}static calculateLevelParameters(e){const n=Math.floor((e-1)/3),s=(e-1)%3,a=6+n,r=3+s;return{nodeCount:a,connectionsPerNode:r}}static generateSolvableLevel(e,t,i){const n=this.createNonIntersectingLayout(e,i),s=this.generateNonIntersectingConnections(n,t),a={circles:this.deepCopyCircles(n),lines:this.deepCopyLines(s)};this.verifySolutionNonIntersecting(a.circles,a.lines),this.scrambleNodePositions(n,i);const r=Math.min(...n.map(o=>o.connections.length));return console.log(`Generated level: ${n.length} nodes, ${s.length} lines`),r<3&&console.error("ERROR: Some nodes have fewer than 3 connections!"),{circles:n,lines:s,solution:a}}static createNonIntersectingLayout(e,t){const i=[],s=t.x/2,a=t.y/2,r=Math.min(t.x,t.y)/2-100;for(let o=0;o<e;o++){const c=2*Math.PI*o/e,l=s+r*Math.cos(c),h=a+r*Math.sin(c);i.push({id:o,position:{x:l,y:h},radius:this.CIRCLE_RADIUS,isDragging:!1,connections:[]})}return i}static generateNonIntersectingConnections(e,t){const i=[],n=new Set;e.forEach(o=>o.connections=[]);const s=e.map(o=>({circle:o,priority:0}));let a=0;const r=1e3;for(;a<r;){s.sort((c,l)=>{const h=Math.max(0,3-c.circle.connections.length);return Math.max(0,3-l.circle.connections.length)-h});let o=!1;for(const c of s){const l=c.circle;if(l.connections.length>=3)continue;const h=this.findBestNonIntersectingConnectionTarget(l,e,t,n,i);if(!h)continue;const g=`${Math.min(l.id,h.id)}-${Math.max(l.id,h.id)}`;l.connections.push(h.id),h.connections.push(l.id),n.add(g),i.push({from:l.id,to:h.id,isIntersecting:!1}),o=!0;break}if(!o)break;a++}return e.forEach(o=>{for(;o.connections.length<t;){const c=this.findBestNonIntersectingConnectionTarget(o,e,t,n,i);if(!c)break;const l=`${Math.min(o.id,c.id)}-${Math.max(o.id,c.id)}`;o.connections.push(c.id),c.connections.push(o.id),n.add(l),i.push({from:o.id,to:c.id,isIntersecting:!1})}}),i}static findBestNonIntersectingConnectionTarget(e,t,i,n,s){const a=t.filter(o=>o.id!==e.id&&o.connections.length<i&&!e.connections.includes(o.id));if(a.length===0)return null;const r=a.sort((o,c)=>{const l=d.distance(e.position,o.position),h=d.distance(e.position,c.position);return l-h});for(const o of r){const c=`${Math.min(e.id,o.id)}-${Math.max(e.id,o.id)}`;if(n.has(c))continue;if(!this.wouldLineIntersect(e.position,o.position,s,t))return o}return null}static wouldLineIntersect(e,t,i,n){for(const s of i){const a=n.find(o=>o.id===s.from),r=n.find(o=>o.id===s.to);if(!this.linesShareEndpoint(e,t,a.position,r.position)&&d.lineSegmentsIntersect(e,t,a.position,r.position))return!0}return!1}static linesShareEndpoint(e,t,i,n){return d.distance(e,i)<1||d.distance(e,n)<1||d.distance(t,i)<1||d.distance(t,n)<1}static scrambleNodePositions(e,t){e.forEach(s=>{let a,r=0,o=null,c=-1;do{a=d.randomPositionDistributed(t.x,t.y,80);const l=Math.min(...e.filter(h=>h.id!==s.id).map(h=>d.distance(a,h.position)));l>c&&(c=l,o=a),r++}while(r<200&&e.some(l=>l.id!==s.id&&d.distance(a,l.position)<this.MIN_DISTANCE));s.position=o||a})}static deepCopyCircles(e){return e.map(t=>({...t,position:{...t.position},connections:[...t.connections]}))}static deepCopyLines(e){return e.map(t=>({...t}))}static verifySolutionNonIntersecting(e,t){let i=0;for(let n=0;n<t.length;n++)for(let s=n+1;s<t.length;s++){const a=t[n],r=t[s];if(this.shareEndpoint(a,r))continue;const o=e.find(g=>g.id===a.from),c=e.find(g=>g.id===a.to),l=e.find(g=>g.id===r.from),h=e.find(g=>g.id===r.to);d.lineSegmentsIntersect(o.position,c.position,l.position,h.position)&&(i++,console.error(`SOLUTION ERROR: Lines ${a.from}-${a.to} and ${r.from}-${r.to} intersect!`))}i>0?console.error(`SOLUTION VERIFICATION FAILED: Found ${i} intersections in the solution!`):console.log("SOLUTION VERIFICATION PASSED: No intersections found in the solution.")}static shareEndpoint(e,t){return e.from===t.from||e.from===t.to||e.to===t.from||e.to===t.to}}class p{static updateIntersections(e,t){t.forEach(i=>i.isIntersecting=!1);for(let i=0;i<t.length;i++)for(let n=i+1;n<t.length;n++){const s=t[i],a=t[n];if(this.shareEndpoint(s,a))continue;const r=e.find(h=>h.id===s.from),o=e.find(h=>h.id===s.to),c=e.find(h=>h.id===a.from),l=e.find(h=>h.id===a.to);d.lineSegmentsIntersect(r.position,o.position,c.position,l.position)&&(s.isIntersecting=!0,a.isIntersecting=!0)}}static shareEndpoint(e,t){return e.from===t.from||e.from===t.to||e.to===t.from||e.to===t.to}}class f{canvas;ctx;canvasSize;constructor(e){this.canvas=e;const t=e.getContext("2d");if(!t)throw new Error("Failed to get 2D context");this.ctx=t,this.canvasSize={x:e.width,y:e.height}}resize(e,t){this.canvas.width=e,this.canvas.height=t,this.canvasSize={x:e,y:t}}clear(){this.ctx.clearRect(0,0,this.canvasSize.x,this.canvasSize.y)}render(e,t,i){this.clear(),this.renderLines(t,i,e),this.renderCircles(e,i)}renderLines(e,t,i){e.forEach(n=>{const s=i.find(c=>c.id===n.from),a=i.find(c=>c.id===n.to);let r="#666",o=2;n.isIntersecting?(r="#ff4444",o=3):t!==null&&(n.from===t||n.to===t)&&(r="#4CAF50",o=3),this.ctx.strokeStyle=r,this.ctx.lineWidth=o,this.ctx.lineCap="round",this.ctx.beginPath(),this.ctx.moveTo(s.position.x,s.position.y),this.ctx.lineTo(a.position.x,a.position.y),this.ctx.stroke()})}renderCircles(e,t){e.forEach(i=>{const n=i.id===t;this.ctx.fillStyle=n?"#4CAF50":"#2196F3",this.ctx.beginPath(),this.ctx.arc(i.position.x,i.position.y,i.radius,0,2*Math.PI),this.ctx.fill(),this.ctx.strokeStyle=n?"#2E7D32":"#1976D2",this.ctx.lineWidth=2,this.ctx.stroke(),this.ctx.fillStyle="white",this.ctx.font="bold 18px Arial",this.ctx.textAlign="center",this.ctx.textBaseline="middle",this.ctx.fillText(i.id.toString(),i.position.x,i.position.y)})}}class S{canvas;onCircleDragStart;onCircleDrag;onCircleDragEnd;draggedCircleId=null;isDragging=!1;preventBackNavigation;constructor(e,t,i,n){this.canvas=e,this.onCircleDragStart=t,this.onCircleDrag=i,this.onCircleDragEnd=n,this.preventBackNavigation=this.handlePreventBackNavigation.bind(this),this.setupEventListeners()}setupEventListeners(){this.canvas.addEventListener("mousedown",this.handleMouseDown.bind(this)),this.canvas.addEventListener("mousemove",this.handleMouseMove.bind(this)),this.canvas.addEventListener("mouseup",this.handleMouseUp.bind(this)),this.canvas.addEventListener("mouseleave",this.handleMouseUp.bind(this)),this.canvas.addEventListener("touchstart",this.handleTouchStart.bind(this),{passive:!1}),this.canvas.addEventListener("touchmove",this.handleTouchMove.bind(this),{passive:!1}),this.canvas.addEventListener("touchend",this.handleTouchEnd.bind(this),{passive:!1}),this.canvas.addEventListener("touchcancel",this.handleTouchEnd.bind(this),{passive:!1})}handleMouseDown(e){e.preventDefault();const t=this.getMousePosition(e);this.handlePointerDown(t)}handleMouseMove(e){if(e.preventDefault(),this.draggedCircleId!==null){const t=this.getMousePosition(e);this.handlePointerMove(t)}}handleMouseUp(e){e.preventDefault(),this.handlePointerUp()}handleTouchStart(e){if(e.preventDefault(),e.stopPropagation(),e.touches.length===1){const t=e.touches[0],i=this.getTouchPosition(t);this.handlePointerDown(i)}}handleTouchMove(e){if(e.preventDefault(),e.stopPropagation(),e.touches.length===1&&this.draggedCircleId!==null){const t=e.touches[0],i=this.getTouchPosition(t);this.handlePointerMove(i)}}handleTouchEnd(e){e.preventDefault(),e.stopPropagation(),this.handlePointerUp()}handlePointerDown(e){const t=this.findCircleAtPosition(e);t!==null&&(this.draggedCircleId=t,this.isDragging=!0,document.addEventListener("touchstart",this.preventBackNavigation,{passive:!1}),document.addEventListener("touchmove",this.preventBackNavigation,{passive:!1}),this.onCircleDragStart(t,e))}handlePointerMove(e){this.draggedCircleId!==null&&this.onCircleDrag(this.draggedCircleId,e)}handlePointerUp(){this.draggedCircleId!==null&&(this.onCircleDragEnd(this.draggedCircleId),this.draggedCircleId=null,this.isDragging=!1,document.removeEventListener("touchstart",this.preventBackNavigation),document.removeEventListener("touchmove",this.preventBackNavigation))}findCircleAtPosition(e){return null}getMousePosition(e){const t=this.canvas.getBoundingClientRect();return{x:e.clientX-t.left,y:e.clientY-t.top}}getTouchPosition(e){const t=this.canvas.getBoundingClientRect();return{x:e.clientX-t.left,y:e.clientY-t.top}}handlePreventBackNavigation(e){this.isDragging&&(e.preventDefault(),e.stopPropagation())}updateCircleHitTest(e){this.findCircleAtPosition=t=>{for(const i of e)if(d.pointInCircle(t,i.position,i.radius))return i.id;return null}}}class u{static SAVE_KEY="untangle-game-save";static LEVEL_KEY="untangle-game-level";static AUTO_SAVE_DELAY=1e3;autoSaveTimeout=null;saveGameState(e){try{const t={currentLevel:e.currentLevel,circles:this.deepCopyCircles(e.circles),lines:this.deepCopyLines(e.lines),isCompleted:e.isCompleted,levelConfigs:Array.from(e.levelConfigs.entries()).map(([i,n])=>({levelNumber:i,config:this.deepCopyLevelConfig(n)})),lastSaved:Date.now()};localStorage.setItem(u.SAVE_KEY,JSON.stringify(t)),localStorage.setItem(u.LEVEL_KEY,e.currentLevel.toString()),console.log("Game state saved successfully")}catch(t){console.error("Failed to save game state:",t)}}loadGameState(){try{const e=localStorage.getItem(u.SAVE_KEY);if(!e)return null;const t=JSON.parse(e),i=new Map;return t.levelConfigs.forEach(({levelNumber:n,config:s})=>{i.set(n,s)}),{currentLevel:t.currentLevel,circles:t.circles,lines:t.lines,isCompleted:t.isCompleted,levelConfigs:i}}catch(e){return console.error("Failed to load game state:",e),null}}loadCurrentLevel(){const e=localStorage.getItem(u.LEVEL_KEY);return e?parseInt(e,10):1}scheduleAutoSave(e){this.autoSaveTimeout!==null&&clearTimeout(this.autoSaveTimeout),this.autoSaveTimeout=window.setTimeout(()=>{this.saveGameState(e),this.autoSaveTimeout=null},u.AUTO_SAVE_DELAY)}cancelAutoSave(){this.autoSaveTimeout!==null&&(clearTimeout(this.autoSaveTimeout),this.autoSaveTimeout=null)}clearSaveData(){localStorage.removeItem(u.SAVE_KEY),localStorage.removeItem(u.LEVEL_KEY),console.log("Save data cleared")}hasSaveData(){return localStorage.getItem(u.SAVE_KEY)!==null}getLastSaveTime(){try{const e=localStorage.getItem(u.SAVE_KEY);return e?JSON.parse(e).lastSaved:null}catch(e){return console.error("Failed to get last save time:",e),null}}deepCopyCircles(e){return e.map(t=>({...t,position:{...t.position},connections:[...t.connections]}))}deepCopyLines(e){return e.map(t=>({...t}))}deepCopyLevelConfig(e){return{...e,circles:this.deepCopyCircles(e.circles),lines:this.deepCopyLines(e.lines),canvasSize:{...e.canvasSize},solution:e.solution?{circles:this.deepCopyCircles(e.solution.circles),lines:this.deepCopyLines(e.solution.lines)}:void 0}}}class C{canvas;renderer;inputManager;saveManager;gameState;animationId=null;currentSolution=null;levelDisplay;restartButton;newGameButton;solveButton;congratulationsElement;nextLevelButton;newGameDialog;confirmNewGameButton;cancelNewGameButton;constructor(e){this.canvas=e,this.renderer=new f(e),this.saveManager=new u,this.gameState={circles:[],lines:[],draggedCircleId:null,canvasSize:{x:0,y:0},currentLevel:1,isCompleted:!1,levelConfigs:new Map},this.levelDisplay=document.getElementById("level-display"),this.restartButton=document.getElementById("restart-btn"),this.newGameButton=document.getElementById("new-game-btn"),this.solveButton=document.getElementById("solve-btn"),this.congratulationsElement=document.getElementById("congratulations"),this.nextLevelButton=document.getElementById("next-level-btn"),this.newGameDialog=document.getElementById("new-game-dialog"),this.confirmNewGameButton=document.getElementById("confirm-new-game-btn"),this.cancelNewGameButton=document.getElementById("cancel-new-game-btn"),this.restartButton.addEventListener("click",()=>this.initializeGame()),this.newGameButton.addEventListener("click",()=>this.showNewGameDialog()),this.solveButton.addEventListener("click",()=>this.showSolution()),this.nextLevelButton.addEventListener("click",()=>this.nextLevel()),this.confirmNewGameButton.addEventListener("click",()=>this.startNewGame()),this.cancelNewGameButton.addEventListener("click",()=>this.hideNewGameDialog()),this.inputManager=new S(e,this.onCircleDragStart.bind(this),this.onCircleDrag.bind(this),this.onCircleDragEnd.bind(this)),this.setupCanvas(),this.loadSavedGameState(),this.initializeGame(),this.gameLoop()}loadSavedGameState(){const e=this.saveManager.loadGameState();e?(console.log("Loading saved game state",{circles:e.circles?.length||0,lines:e.lines?.length||0,level:e.currentLevel,isCompleted:e.isCompleted}),this.gameState.circles=e.circles||[],this.gameState.lines=e.lines||[],this.gameState.currentLevel=e.currentLevel||1,this.gameState.isCompleted=e.isCompleted||!1,this.gameState.levelConfigs=e.levelConfigs||new Map):(console.log("Starting new game - no saved state found"),this.gameState.currentLevel=this.saveManager.loadCurrentLevel())}setupCanvas(){const e=()=>{const t=this.canvas.parentElement,i=t.clientWidth,n=t.clientHeight;this.renderer.resize(i,n),this.gameState.canvasSize={x:i,y:n}};e(),window.addEventListener("resize",e)}initializeGame(){this.gameState.isCompleted=!1,this.hideCongratulations();const e=this.gameState.levelConfigs.get(this.gameState.currentLevel);if(this.gameState.circles.length>0&&this.gameState.lines.length>0)console.log("Using saved game state for current level",{circles:this.gameState.circles.length,lines:this.gameState.lines.length,level:this.gameState.currentLevel}),this.currentSolution=e?.solution||null;else{console.log("Generating new level",{level:this.gameState.currentLevel,canvasSize:this.gameState.canvasSize,hasStoredConfig:!!e});const t=v.generateLevel(this.gameState.currentLevel,this.gameState.canvasSize,e);this.gameState.circles=t.circles,this.gameState.lines=t.lines,this.currentSolution=t.solution||null,e||this.storeLevelConfig(this.gameState.currentLevel,t.circles,t.lines,t.solution)}this.inputManager.updateCircleHitTest(this.gameState.circles),p.updateIntersections(this.gameState.circles,this.gameState.lines),this.updateLevelDisplay(),this.saveManager.saveGameState(this.gameState)}updateLevelDisplay(){this.levelDisplay.textContent=`Level ${this.gameState.currentLevel}`}showCongratulations(){this.congratulationsElement.classList.add("show")}hideCongratulations(){this.congratulationsElement.classList.remove("show")}nextLevel(){this.gameState.currentLevel++,this.saveManager.saveGameState(this.gameState),this.initializeGame()}showNewGameDialog(){this.newGameDialog.classList.add("show")}hideNewGameDialog(){this.newGameDialog.classList.remove("show")}startNewGame(){this.gameState.currentLevel=1,this.gameState.levelConfigs.clear(),this.gameState.circles=[],this.gameState.lines=[],this.gameState.isCompleted=!1,this.saveManager.clearSaveData(),this.hideNewGameDialog(),this.initializeGame()}showSolution(){if(!this.currentSolution){console.warn("No solution available for current level");return}const e=this.deepCopyCircles(this.gameState.circles),t=this.deepCopyLines(this.gameState.lines);this.gameState.circles=this.deepCopyCircles(this.currentSolution.circles),this.gameState.lines=this.deepCopyLines(this.currentSolution.lines),this.inputManager.updateCircleHitTest(this.gameState.circles),p.updateIntersections(this.gameState.circles,this.gameState.lines),setTimeout(()=>{this.gameState.circles=e,this.gameState.lines=t,this.inputManager.updateCircleHitTest(this.gameState.circles),p.updateIntersections(this.gameState.circles,this.gameState.lines)},3e3)}storeLevelConfig(e,t,i,n){const s={circles:this.deepCopyCircles(t),lines:this.deepCopyLines(i),levelNumber:e,canvasSize:{...this.gameState.canvasSize},solution:n?{circles:this.deepCopyCircles(n.circles),lines:this.deepCopyLines(n.lines)}:void 0};this.gameState.levelConfigs.set(e,s)}deepCopyCircles(e){return e.map(t=>({...t,position:{...t.position},connections:[...t.connections]}))}deepCopyLines(e){return e.map(t=>({...t}))}checkForCompletion(){if(this.gameState.isCompleted)return;this.gameState.lines.some(t=>t.isIntersecting)||(this.gameState.isCompleted=!0,this.showCongratulations(),this.saveManager.saveGameState(this.gameState))}onCircleDragStart(e,t){const i=this.gameState.circles.find(n=>n.id===e);i&&(i.isDragging=!0,this.gameState.draggedCircleId=e)}onCircleDrag(e,t){const i=this.gameState.circles.find(n=>n.id===e);i&&(i.position.x=d.clamp(t.x,i.radius,this.gameState.canvasSize.x-i.radius),i.position.y=d.clamp(t.y,i.radius,this.gameState.canvasSize.y-i.radius),p.updateIntersections(this.gameState.circles,this.gameState.lines),this.saveManager.scheduleAutoSave(this.gameState))}onCircleDragEnd(e){const t=this.gameState.circles.find(i=>i.id===e);t&&(t.isDragging=!1,this.gameState.draggedCircleId=null,this.checkForCompletion(),this.saveManager.saveGameState(this.gameState))}gameLoop(){this.renderer.render(this.gameState.circles,this.gameState.lines,this.gameState.draggedCircleId),this.animationId=requestAnimationFrame(()=>this.gameLoop())}destroy(){this.animationId!==null&&cancelAnimationFrame(this.animationId),this.saveManager.saveGameState(this.gameState)}}document.addEventListener("DOMContentLoaded",()=>{const m=document.createElement("canvas"),e=document.getElementById("game-container");if(!e)throw new Error("Game container not found");e.appendChild(m);const t=new C(m);window.addEventListener("beforeunload",()=>{t.destroy()})});
